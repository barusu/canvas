{"version":3,"sources":["2018-06-05/script/canvas.js"],"names":["scope","RAF","window","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","msRequestAnimationFrame","callback","setTimeout","getDistance","p1","p2","Math","sqrt","getHexagon","c","radius","direction","arguments","length","undefined","t","Trail","paths","speed","this","old","prototype","paint","shadowBlur","step","ctx","grd","addColorStop","fillStyle","y","shadowColor","beginPath","createRadialGradient","x","arc","fill","closePath","restore","PI","Points","start","end","distance","vx","vy","progress","i","points","initCanvas","el","canvas","document","getElementById","nodeType","nodeName","devicePixelRatio","webkitBackingStorePixelRatio","backingStorePixelRatio","console","scale","clientWidth","ratio","clientHeight","error","get2DContext","loop","trails","prev","globalCompositeOperation","height","addTrail","push","r","log"],"mappings":"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","file":"canvas.js","sourcesContent":["/**\n * Canvas\n * @author shiro https://github.com/barusu\n */\n\n(function(scope) {\n  /**\n   * Base\n   */\n  var RAF = (function() {\n    return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {\n      window.setTimeout(callback, 1000 / 60);\n    };\n  })();\n\n  // 获取 Canvas 2D 上下文\n  function get2DContext(canvas) {\n    var ctx;\n\n    if(typeof(canvas) === 'string') canvas = document.getElementById(canvas);\n    if(canvas && canvas.nodeType === 1 && canvas.nodeName === 'CANVAS') {\n      ctx = canvas.getContext('2d');\n      // 获取设备分辨率信息\n      const devicePixelRatio = window.devicePixelRatio || 1;\n      const backingStoreRatio = ctx.webkitBackingStorePixelRatio ||\n                                ctx.mozBackingStorePixelRatio ||\n                                ctx.msBackingStorePixelRatio ||\n                                ctx.oBackingStorePixelRatio ||\n                                ctx.backingStorePixelRatio || 1;\n      const ratio = devicePixelRatio / backingStoreRatio;\n      // 按比例缩放Canvas\n      canvas.width = canvas.clientWidth * ratio;\n      canvas.height = canvas.clientHeight * ratio;\n      ctx.scale(ratio, ratio);\n      return ctx;\n    }else {\n      console.error('El is not a Canvas');\n      return false;\n    }\n  }\n\n  // 计算两点之间的直线距离\n  function getDistance(p1, p2) {\n    return Math.sqrt((p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]));\n  }\n\n  // 直线路径转点数组\n  function pathToPoints(path) {\n    var points = [], start, end, distance, vx, vy, progress, i;\n    for(i = 0; i < this.paths.length - 1; i++) {\n      start = this.paths[i];\n      end = this.paths[i + 1];\n      distance = Math.floor(getDistance(start, end));\n      vx = (end[0] - start[0]) / distance;\n      vy = (end[1] - start[1]) / distance;\n      progress = 0;\n      while(progress < distance) {\n        progress++;\n        points.push([start[0] + vx * progress, start[1] + vy * progress]);\n      }\n    }\n    return points;\n  }\n\n  // 圆转点数组 (顺时针)\n  function circleToPoints(c, radius) {\n    var points = [], min = 1 / radius, progress = 0;\n    while(progress < Math.PI * 2) {\n      points.push([c[0] + (Math.sin(progress) * radius), c[1]] - (radius * Math.cos(progress)));\n      progress += min;\n    }\n    points.push([c[0], c[1] -radius]);\n    return points;\n  }\n\n\n  /**\n   * Tool\n   */\n  // 计算六边形的坐标 [竖: 逆时针, 顶部开始  横: 逆时针, 左边开始](vertical, transverse)\n  function getHexagon(c, radius, direction = 'vertical') {\n    if(c && radius && c.length === 2) {\n      var t = radius / 2 * Math.sqrt(3);\n      if(direction === 'vertical') {\n        return [\n          [c[0], c[1] - radius],\n          [c[0] - t, c[1] - (radius / 2)],\n          [c[0] - t, c[1] + (radius / 2)],\n          [c[0], c[1] + radius],\n          [c[0] + t, c[1] + (radius / 2)],\n          [c[0] + t, c[1] - (radius / 2)],\n          [c[0], c[1] - radius]\n        ];\n      }else {\n        return [\n          [c[0] -radius, c[1]],\n          [c[0] - (radius / 2), c[1] - t],\n          [c[0] + (radius / 2), c[1] - t],\n          [c[0] + radius, c[1]],\n          [c[0] + (radius / 2), c[1] + t],\n          [c[0] - (radius / 2), c[1] + t],\n          [c[0] - radius, c[1]]\n        ];\n      }\n    }else return [];\n  }\n\n  // 创建轨迹类\n  var Trail = function(paths, speed = 1) {\n    this.paths = paths;\n    this.speed = speed;\n    this.shadowColor = '#fff';\n    this.shadowBlur = 10;\n    this.step = 0;\n    this.radius = 2;\n    this.old = [];\n  }\n  Trail.prototype = {\n    paint(ctx) {\n      var x = this.Points[this.step][0];\n      var y = this.Points[this.step][1];\n      if(this.old[0] != x || this.old[1] != y) {\n        this.old = [x, y];\n        ctx.save();\n        var grd = ctx.createRadialGradient(x, y, 1, x, y, this.radius);\n        grd.addColorStop(0, \"rgba(255,255,255,.4)\");\n        grd.addColorStop(1, \"rgba(255,255,255,0)\");\n        ctx.fillStyle = grd;\n        ctx.shadowColor = this.shadowColor;\n        ctx.shadowBlur = this.shadowBlur;\n        ctx.beginPath();\n        ctx.arc(x, y, this.radius * 2, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.closePath();\n        ctx.restore();\n      }\n      this.step ++;\n      if(this.step >= this.Points.length) this.step = 0;\n    },\n    get Points() {\n      var points = [], start, end, distance, vx, vy, progress, i;\n      for(i = 0; i < this.paths.length - 1; i++) {\n        start = this.paths[i];\n        end = this.paths[i + 1];\n        distance = Math.floor(getDistance(start, end));\n        vx = (end[0] - start[0]) / distance;\n        vy = (end[1] - start[1]) / distance;\n        progress = 0;\n        while(progress < distance) {\n          progress += this.speed;\n          points.push([start[0] + vx * progress, start[1] + vy * progress]);\n        }\n      }\n      return points;\n    }\n  };\n\n  scope.initCanvas = function(el) {\n    var ctx = get2DContext(el);\n    var trails = [];\n\n    function loop() {\n      ctx.fillStyle = 'rgba(0,0,0,.95)';\n      var prev = ctx.globalCompositeOperation;\n      ctx.globalCompositeOperation = 'destination-in';\n      ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n      ctx.globalCompositeOperation = prev;\n\n      trails.forEach(i => {\n        i.paint(ctx);\n      });\n      RAF(() => {\n        loop();\n      });\n    }\n\n    loop();\n\n    return {\n      addTrail(paths) {\n        trails.push(new Trail(paths));\n      },\n      getHexagon(c, r) {\n        trails.push(new Trail(getHexagon(c, r)));\n        console.log(getHexagon(c, r));\n      }\n    };\n  };\n})(window);\n\nvar canvas = initCanvas('canvas');\n\ncanvas.getHexagon([300, 200], 150);\n\n\n\n\n\n"]}