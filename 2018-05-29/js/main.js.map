{"version":3,"sources":["2018-05-29/script/main.js"],"names":["scope","requestAnimationFrame","window","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","msRequestAnimationFrame","Line","a","y","this","radian","na","x","nb","prototype","b","ctx","setLineDash","s","cp","e","strokeStyle","lineWidth","drawQuadraticCurve","quadraticCurveTo","stroke","closePath","update","updateLine","get2DContext","el","canvas","document","getElementById","nodeType","nodeName","devicePixelRatio","webkitBackingStorePixelRatio","backingStorePixelRatio","console","scale","clientWidth","ratio","clientHeight","error","lines","addCurve","arguments","length","undefined","push","poi","initCanvas","sp","status","offsetX","offsetY"],"mappings":"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","file":"main.js","sourcesContent":["/**\n * Day 3\n * 画虚线\n * 2018-05-29\n */\n\n(function(scope) {\n  var RAF = (function() {\n    return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {\n      window.setTimeout(callback, 1000 / 60);\n    };\n  })();\n  // 获取 Canvas 2D 上下文\n  function get2DContext(canvas) {\n    var ctx;\n\n    if(typeof(canvas) === 'string') canvas = document.getElementById(canvas);\n    if(canvas && canvas.nodeType === 1 && canvas.nodeName === 'CANVAS') {\n      ctx = canvas.getContext('2d');\n      // 获取设备分辨率信息\n      const devicePixelRatio = window.devicePixelRatio || 1;\n      const backingStoreRatio = ctx.webkitBackingStorePixelRatio ||\n                                ctx.mozBackingStorePixelRatio ||\n                                ctx.msBackingStorePixelRatio ||\n                                ctx.oBackingStorePixelRatio ||\n                                ctx.backingStorePixelRatio || 1;\n      const ratio = devicePixelRatio / backingStoreRatio;\n      // 按比例缩放Canvas\n      canvas.width = canvas.clientWidth * ratio;\n      canvas.height = canvas.clientHeight * ratio;\n      ctx.scale(ratio, ratio);\n      return ctx;\n    }else {\n      console.error('El is not a Canvas');\n      return false;\n    }\n  }\n  // 绘制贝塞尔曲线\n  function drawQuadraticCurve(ctx, s, cp, e) {\n    ctx.beginPath();\n    ctx.moveTo(s.x, s.y);\n    ctx.quadraticCurveTo(cp.x, cp.y, e.x, e.y);\n    ctx.stroke();\n    ctx.closePath();\n  }\n\n  // 创建线条类\n  var Line = function(a, b, radian) {\n    this.a = {x: a.x, y: a.y};\n    this.b = {x: b.x, y: b.y};\n    this.radian = radian;\n    this.na = {x: a.x, y: a.y};\n    this.nb = {x: b.x, y: b.y};\n  }\n  Line.prototype = {\n    paint(ctx) {\n      // 设置画笔\n      ctx.setLineDash([8,4]);\n      ctx.lineWidth = 2;\n      ctx.strokeStyle = '#f36';\n\n      drawQuadraticCurve(ctx, this.a, this.cp, this.b);\n    },\n    update() {\n      // 如坐标变化则进行逐帧归位\n      if(this.na.x !== this.a.x) this.a.x += this.na.x - this.a.x > 0 ? 1 : -1;\n      if(this.na.y !== this.a.y) this.a.y += this.na.y - this.a.y > 0 ? 1 : -1;\n      if(this.nb.x !== this.b.x) this.b.x += this.nb.x - this.b.x > 0 ? 1 : -1;\n      if(this.nb.y !== this.b.y) this.b.y += this.nb.y - this.b.y > 0 ? 1 : -1;\n    },\n    updateLine(a, b, radian) {\n      this.radian = radian;\n      this.na = {x: a.x, y: a.y};\n      this.nb = {x: b.x, y: b.y};\n    },\n    // 计算贝塞尔曲线控制点坐标\n    get cp() {\n      if(this.a.x < this.b.x) {\n        return {\n          x: (this.a.x + this.b.x) / 2 + (this.b.y - this.a.y) / this.radian,\n          y: (this.a.y + this.b.y) / 2 - (this.b.x - this.a.x) / this.radian\n        };\n      }else {\n        return {\n          x: (this.a.x + this.b.x) / 2 - (this.b.y - this.a.y) / this.radian,\n          y: (this.a.y + this.b.y) / 2 + (this.b.x - this.a.x) / this.radian\n        };\n      }\n    }\n  };\n\n  scope.initCanvas = function(el) {\n    var ctx = get2DContext(el);\n    var lines = [];\n\n    function loop() {\n      lines.forEach(i => {\n        i.update();\n      });\n      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n      lines.forEach(i => {\n        i.paint(ctx);\n      });\n      RAF(() => {\n        loop();\n      });\n    }\n\n    return {\n      addCurve(a, b, radian = 2.6) {\n        var l = lines.push(new Line(a, b, radian));\n        return l - 1;\n      },\n      updateLine(poi, a, b, radian = 2.6) {\n        lines[poi].updateLine(a, b, radian);\n      }\n    };\n  };\n})(window);\n\nvar canvas = initCanvas('canvas');\nvar sp, status = true, poi;\n\nfunction draw(e) {\n  if(sp) {\n    if(status) {\n      poi = canvas.addCurve(sp, {x: e.offsetX, y: e.offsetY});\n      status = false;\n    }else {\n      canvas.updateLine(poi, sp, {x: e.offsetX, y: e.offsetY})\n    }\n    sp = null;\n  }else {\n    sp = {x: e.offsetX, y: e.offsetY};\n  }\n}\n\n\n\n\n"]}